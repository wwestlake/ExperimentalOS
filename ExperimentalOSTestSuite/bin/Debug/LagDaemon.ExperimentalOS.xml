<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LagDaemon.ExperimentalOS</name>
    </assembly>
    <members>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU">
            <summary>
            Emulates a CPU with task switching, memory management, registers and instruction codes.
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.Interfaces.IStartable">
            <summary>
            represents a startable process in the CPU
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IStartable.Start">
            <summary>
            Start a virtual CPU process
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.#ctor(LagDaemon.ExperimentalOS.CPU.CPUHardware.HardwareConfiguration,LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernel)">
            <summary>
            Constructis a CPU
            </summary>
            <param name="cpuKernel">The Kernel for this CPU</param>
            <param name="config">The configuration object for this CPU</param>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.RegisterCount">
            <summary>
            Count of available registers
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.Registers">
            <summary>
            Array of actual registers in this CPU
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.InstructionQueue">
            <summary>
            The instruction queue loaded in the order of executing instructions.
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.CpuKernel">
            <summary>
            The CPUKernel for this CPU
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.ZeroFlag">
            <summary>
            A math operation that results in zero sets this flag true
            Flag will remain in this state until another math operation
            changes it
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.ComparisonFlag">
            <summary>
            Holds the result of the last Compare instruction
            This flag will remain in this state until another compare
            statement or a ClearCompare instruction is encountered.
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.ProcessorMode">
            <summary>
            The current operational mode of the processor
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.CurrentInstruction">
            <summary>
            The currently executing instruction
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.Devices">
            <summary>
            Controls all external devices and creates input output ports
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPU.Memory">
            <summary>
            The main memory of the system
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUException">
            <summary>
            Thrown by the CPU when an error occurs
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUException.#ctor(System.String)">
            <summary>
            Constuct a CPUException with message
            </summary>
            <param name="message">The Message</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUException.#ctor(System.String,System.Object[])">
            <summary>
            Construct a CPUException with format and arguments
            </summary>
            <param name="format">Format string</param>
            <param name="args">Argmuments</param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUFactory">
            <summary>
            Constructs various CPU configruations
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUFactory.CreateSingleTaskCPU(System.Collections.Generic.IList{LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction})">
            <summary>
            Constructs a single task CPU and returns an IStartable interface
            </summary>
            <returns>IStartable</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.CPUFactory.Factory(LagDaemon.ExperimentalOS.CPU.CPUHardware.HardwareConfiguration)">
            <summary>
            Produces a CPU factory
            </summary>
            <param name="config">The configuaration of this CPU</param>
            <returns>A CPUFactory</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUHardware.HardwareConfiguration">
            <summary>
            Represents the configuration of the hardware simulation
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUHardware.HardwareConfiguration.#ctor(System.Int32)">
            <summary>
            Consructs a HardwareConfiguration
            </summary>
            <param name="registers">number of registers for the CPU</param>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUHardware.HardwareConfiguration.Registers">
            <summary>
            Gets or sets the number of registers for this CPU
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernel">
            <summary>
            Represents the microcode side of the CPU for execution of instruction codes
            and handles CPU level memory management and task switching.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernel.#ctor">
            <summary>
            Constructs a CPUKernel
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelException">
            <summary>
            A CPUKernel Exception is thrown in the CPU Kernel code when ever a condition is encountered
            that will prevent the correct operation of the CPU Kernel.  In some cases they may be caught and recovered.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelException.#ctor(System.String)">
            <summary>
            Create a CPUKernelException from a string message
            </summary>
            <param name="message">The Message</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelException.#ctor(System.String,System.Object[])">
            <summary>
            Create a CPUKernelMessage from a format string and arguments
            </summary>
            <param name="format">Format String</param>
            <param name="args">Arguments</param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory">
            <summary>
            A factory for creating CPUKernels
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.Interfaces.ICPUKernelFactory">
            <summary>
            Represents a CPUKernel
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.ICPUKernelFactory.Mode(LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUModes)">
            <summary>
            CPUKernel Mode
            </summary>
            <param name="mode">The Mode</param>
            <returns>ICPUKernelFactory</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.ICPUKernelFactory.CreateKernel(System.Collections.Generic.IList{LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction})">
            <summary>
            Creates the Kernel for this CPU
            </summary>
            <param name="program">A List of instructions to load</param>
            <returns>A CPUKernel</returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.Interfaces.ICPUKernelFactory.InstrucitnoFactory">
            <summary>
            Gets the InstructionFactory for this CPUKernel
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory.#ctor">
            <summary>
            Constructs a CPUKernel Factory
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory.Mode(LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUModes)">
            <summary>
            Sets the mode of thie CPUKernelFactory
            </summary>
            <param name="mode">Mode may be any CPUModes</param>
            <returns>The CPUKernelFactory</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory.CreateKernel(System.Collections.Generic.IList{LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction})">
            <summary>
            Creates a Kernel for this CPU
            </summary>
            <param name="program">A list of instructions to load into the CPU</param>
            <returns>A CPUKernel</returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory.InstrucitnoFactory">
            <summary>
            Gets the instruction factory for this Kernel
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUKernelFactory.Factory">
            <summary>
            Gets the Kernel factory for this kernel
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUModes">
            <summary>
            Represents the modes that the CPU can be set to
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUModes.SingleTasking">
            <summary>
            Runs one task at one time
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.CPUModes.MultiTasking">
            <summary>
            Runs multiple tasks through multitasking
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.ComparisonFlags">
            <summary>
            Comparison flags for CPU
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ComparisonFlags.Cleared">
            <summary>
            Flag has no meaning, will cause a ProcessorException on any conditional jump instruction
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ComparisonFlags.LessThan">
            <summary>
            Last compare was a less than condition
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ComparisonFlags.GreateThan">
            <summary>
            Last compare was a greater than condition
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ComparisonFlags.Equal">
            <summary>
            Last compare was an equal condition
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.ProcessorModes">
            <summary>
            Processor modes
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ProcessorModes.Stopped">
            <summary>
            CPU is not runnint
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ProcessorModes.SingleTasking">
            <summary>
            CPU is operating in SingleTasking mode
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ProcessorModes.MultiTasking">
            <summary>
            CPU is operating in multitasking mode
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.ProcessorModes.Exception">
            <summary>
            CPU is in an exception state trying to recover if possible before entering stopped state
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction">
            <summary>
            Represents a single atomic CPU instruction.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes)">
            <summary>
            Constructs an initial instruction which may require further initialization
            by a derived class
            </summary>
            <param name="code">The instruction code for this instruction</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes,System.String)">
            <summary>
            Constructs an Instruction from InstructionCode and Comment
            </summary>
            <param name="code">The InstructionCode</param>
            <param name="comment">The Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.CreateInstruction(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Creates an instruction from an assembly line
            </summary>
            <param name="assemblyLine">The assembly line to use</param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns>An instruction object</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine">The line of assembly to create the instruction from</param>
            <param name="factory">the instruction factory for this kernel</param>
            <returns>An Instruction object</returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.ToString">
            <summary>
            Converts this to a disassembled string
            </summary>
            <returns>The assembly language equivilant</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.PreProcess(System.String)">
            <summary>
            Cleans up the source line
            
            TODO: Add symbol lookup here and replace with addresses.????
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.Execute">
            <summary>
            Internally set by the CPUKernal for execution of the instruction
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.Code">
            <summary>
            Returns the instruction code for this instruction
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.Comment">
            <summary>
            Any comment from the assembly file or from construction
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.Instruction.Size">
            <summary>
            Returns the actual size in bytes that this instruction requires for storage
            in memory.  This size includes the data.
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes">
            <summary>
            Defines the CPU instruction set
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.NOP">
            <summary>
            No operation
            NOP
            </summary>
            <remarks>Inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Move">
            <summary>
            Moves data from register 1 to register 2
            Move r1, r2
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Load">
            <summary>
            Loads data from memory to a register
            Load r1, value          ; imediate
            Load r1, $address       ; direct addressing
            Load r1, r2            ; indirect addressing
            Load r1, r2, $address   ; indexed indirect addressing  
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Store">
            <summary>
            stores data from a register or imnediate to memory
            Store r1, value         // imediate value to address in r1
            Store r1, $address      // direct addressing
            Store r1, r2            // indirect addressing address in r2
            Store r1, r2, $address  // indexed indirect addressing imediate address + r2 index
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Push">
            <summary>
            pushes a register onto the stack
            Push r1
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Pop">
            <summary>
            pops data from the stack into a register
            Pop R1
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.In">
            <summary>
            reads from an input port to a register
            In r1, $port            // port number imedediate
            In r1, r2               // port numher in register 2
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Out">
            <summary>
            writes froma register to an output port
            Out r1, $port           
            Out r1, r2
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Jump">
            <summary>
            jumps the execution address to the specified address in a register
            Jump $address           // imediate address
            Jump r1                 // address in r1
            Jump r1, $address        // r1 indexes into address (address + r1)
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Call">
            <summary>
            pushes the current address to the stack then jumps the desired address
            Call $address
            Call r1
            Call r1, $address
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Return">
            <summary>
            returns from a call by popping the addess from the stack
            Return
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Add">
            <summary>
            Add register 2 to register 3 and stores the result in register 1
            Add r1, r2, r3
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Sub">
            <summary>
            Subtracts r3 from r2 stores result in r1
            Sub r1, r2, r3
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Mul">
            <summary>
            Multiplies r2 by r3 stores result in r1
            Mul r1, r2, r3
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Div">
            <summary>
            Divides r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.And">
            <summary>
            Ands r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Or">
            <summary>
            Ors r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Not">
            <summary>
            Nots r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Xor">
            <summary>
            Xors r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Nand">
            <summary>
            Not Ands r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Nor">
            <summary>
            Not Ors r2 by r3 stores result in r1
            Div r1, r2, r3
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Inc">
            <summary>
            Increments register r1 by 1
            Inc r1
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Dec">
            <summary>
            Decrements r1 by 1
            Dec r1
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Compare">
            <summary>
            Compares r1 to r2 and sets the comparison flag to be acted upon my a conditional instruction
            Compare r1, r2
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.ClearCompare">
            <summary>
            Clears the compare flag to Cleared
            ClearCompare
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JE">
            <summary>
            Jump IFF conditional flag is Equal
            JE $address
            JE r1
            JE r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JNE">
            <summary>
            Jump IFF conditional flag is Not Equal (any state other than equal)
            JNE $address
            JNE r1
            JNE r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JGT">
            <summary>
            Jump IFF conditional flag is Greater Than
            JGT $address
            JGT r1
            JGT r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JLT">
            <summary>
            Jump IFF coditional flag is Less Than
            JLT $address
            JLT r1
            JLT r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JZ">
            <summary>
            Jump IFF zero flag is true
            JZ $address
            JZ r1
            JZ r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.JNZ">
            <summary>
            Jump IFF zero flag is not true
            JNZ $address
            JNZ r1
            JNZ r1, $address
            </summary>
            <remarks>inst completed</remarks>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.AllocateMemory">
            <summary>
            Alllocates memory to the processor memory manager and places the allocated memory handle in the designated register r1
            AllocateMemory r1, num
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.FreeMemory">
            <summary>
            Frees previously allocated memory as designated by the handle in r1
            FreeMemory r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.MemoryClear">
            <summary>
            Clears the memory starting at the address in r1 for number of bytes in r2
            MemoryClear r1, r2
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Terminate">
            <summary>
            Terminates the currently running process where r1 contains an exit code for the process which will be returned to the OS Kernel
            Terminate r1
            <remarks>inst completed</remarks>
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Lock">
            <summary>
            Obtains a lock on a process where num is the lock number asscociated with the calling process
            Lock num
            Lock r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Unlock">
            <summary>
            Unlocks a lock obtained by Lock
            Unlock num
            Unlock r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.Sleep">
            <summary>
            Causes the currently executing process to sleep by the specified time in Miliseconds
            Sleep num
            Sleep r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.SetPriority">
            <summary>
            Sets the priority of the currently executing process
            SetPriority num
            SetPriority r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.WaitOnEvent">
            <summary>
            Waits for an event designated by the event handle in r1
            WaitOnEvent r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.FireEvent">
            <summary>
            Fires the event in r1
            FireEvent r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.BeginAtomicBlock">
            <summary>
            Starts an atomic block (this block will not be interupted by taks switching) and returns an AtomicBlock handle in r1
            The atomic block begins with the next executing instruction and ends when EndAtomicBlock is encountered with the 
            appropriate AtomicBlockHandle
            BeginAtomicBlock r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.EndAtomicBlock">
            <summary>
            Ends an AtomicBlock started with BeginAtomicBlock.  r1 must contain the atomic block number that is ending
            EndAtomicBlock r1
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes.EnterMultitaskingMode">
            <summary>
            Starts multi tasking.
            EnterMultitaskingMode
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddInstruction">
            <summary>
            Adds data from register 1 to register 2
            Add r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase">
            <summary>
            Adds data from register 1 to register 2
            Add r1, r2
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a AddInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="r3">Register 3</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a AddInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="r3">Register 3</param>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase)">
            <summary>
            Copies a AddInstruction to this new object
            </summary>
            <param name="inst">The instruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine"></param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns></returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MathBase.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AndInstruction">
            <summary>
            Ands data from register 1 to register 2
            And r1, r2
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.JumpBase.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine">The line of assembly to create the instruction from</param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns>An Instruction object</returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.JumpBase.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.ExecuteInstruction">
            <summary>
            Used to connect an instruction to the CPU Kernal code that executes the instruction
            </summary>
            <param name="instruction">The instruction being executed</param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.TaskCallBackFunction">
            <summary>
            Represents a Task execution thread
            </summary>
            <param name="taskId"></param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction">
            <summary>
            Represents No Operation instruction
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction.#ctor">
            <summary>
            Construciton a ClearCompare Instruciton
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction.#ctor(System.String)">
            <summary>
            Constructs a ClearCompare instruction
            </summary>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction)">
            <summary>
            Copy constructor
            </summary>
            <param name="inst">The ClearCompareInstruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Assembly a ClearCompare Instruction
            </summary>
            <param name="assemblyLine">Assembly line representing a ClearCompare</param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns>The instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ClearCompareInstruction.DisAssemble">
            <summary>
            Generates Assembly code for a ClearCompare instruction
            </summary>
            <returns></returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction">
            <summary>
            Compares data from register 1 to register 2
            Compare r1, r2
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a CompareInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a CompareInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction)">
            <summary>
            Copies a CompareInstruction to this new object
            </summary>
            <param name="inst">The instruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine"></param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns></returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.CompareInstruction.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.DecInstruction">
            <summary>
            Represents a single atomic Push instruction.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.DecInstruction.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a Dec instruction
            </summary>
            <param name="r1">register</param>
            <param name="comment">comments</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.DecInstruction.#ctor(System.Int32)">
            <summary>
            Constructs a Dec instruction
            </summary>
            <param name="r1">register</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.DecInstruction.DisAssemble">
            <summary>
            Converts instruction to assembly language representation
            </summary>
            <returns>String assembly language representation</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.DivInstruction">
            <summary>
            Divs data from register 1 to register 2
            Div r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.IncInstruction">
            <summary>
            Represents a single atomic Push instruction.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.IncInstruction.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a Inc instruction
            </summary>
            <param name="r1">register</param>
            <param name="comment">comments</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.IncInstruction.#ctor(System.Int32)">
            <summary>
            Constructs a Inc instruction
            </summary>
            <param name="r1">register</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.IncInstruction.DisAssemble">
            <summary>
            Converts instruction to assembly language representation
            </summary>
            <returns>String assembly language representation</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory">
            <summary>
            Factory methods for creating instructions
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory">
            <summary>
            InstructionFactory interface
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.FromCode(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes)">
            <summary>
            Create a new instruction from a Code
            </summary>
            <param name="code">The Instruction Code</param>
            <returns>An Instruction Prototype not configured</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nop">
            <summary>
            Create a Nop Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nop(System.String)">
            <summary>
            Create a Nop instruction with comment
            </summary>
            <param name="comment">A Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Move(System.Int32,System.Int32)">
            <summary>
            Create a Move instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Move(System.Int32,System.Int32,System.String)">
            <summary>
            Create a Move isntruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Load(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a Load Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Load(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a Load Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Store(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a Store Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Store(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a Store Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Push(System.Int32,System.String)">
            <summary>
            Create a Push Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Push(System.Int32)">
            <summary>
            Create a Push Instruction
            </summary>
            <param name="r1">Register 1</param>
            <returns></returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Pop(System.Int32,System.String)">
            <summary>
            Create a Pop Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Pop(System.Int32)">
            <summary>
            Create a Pop Instruction
            </summary>
            <param name="r1">Register 1</param>
            <returns></returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.In(System.Int32,System.Int32,System.String)">
            <summary>
            Create a In Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="port">The port to read from</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.In(System.Int32,System.Int32)">
            <summary>
            Create a Pop Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="port">The port to read from</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Out(System.Int32,System.Int32)">
            <summary>
            Creates an Out Instruction
            </summary>
            <param name="r1">Register to send to port</param>
            <param name="port">Port to write to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Out(System.Int32,System.Int32,System.String)">
            <summary>
            Creates an Out Instruction with comment
            </summary>
            <param name="r1">Register to send to port</param>
            <param name="port">The port to write to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Jump(System.Int32,System.Int32)">
            <summary>
            Creates an Jump Instruction
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to jump to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Jump(System.Int32,System.Int32,System.String)">
            <summary>
            Creates an Jump Instruction with comment
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to jump to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Call(System.Int32,System.Int32)">
            <summary>
            Creates a Call Instruction
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to call to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Call(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a Call Instruction with comment
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to call to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Return">
            <summary>
            Creates a Return Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Return(System.String)">
            <summary>
            Creates a Return Instruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Add Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Add(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AddInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Sub(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Sub Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Sub(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a SubInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Mul(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Mul Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Mul(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a MulInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Div(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Div Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Div(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a DivInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.And(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a And Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.And(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AndInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Or(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Or Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Or(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AndInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Not(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Not Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Not(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NotInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Xor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Xor Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Xor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a XortInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nand(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Nand Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nand(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NandtInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Nor Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Nor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NortInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Inc(System.Int32)">
            <summary>
            Creates a Inc Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Inc(System.Int32,System.String)">
            <summary>
            Creates a IncInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Dec(System.Int32)">
            <summary>
            Creates a Dec Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Dec(System.Int32,System.String)">
            <summary>
            Creates a DecInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Compare(System.Int32,System.Int32)">
            <summary>
            Creates a Compare Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Compare(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a CompareInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.ClearCompare">
            <summary>
            Creates a ClearCompare Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.ClearCompare(System.String)">
            <summary>
            Creates a ClearCompareInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JE(System.Int32,System.Int32)">
            <summary>
            Creates a JE Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JE(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JNE(System.Int32,System.Int32)">
            <summary>
            Creates a JNE Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JNE(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JGT(System.Int32,System.Int32)">
            <summary>
            Creates a JGT Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JGT(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JLT(System.Int32,System.Int32)">
            <summary>
            Creates a JLT Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JLT(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JZ(System.Int32,System.Int32)">
            <summary>
            Creates a JZ Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JZ(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JNZ(System.Int32,System.Int32)">
            <summary>
            Creates a JNZ Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.JNZ(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Terminate">
            <summary>
            Creates a Terminate Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory.Terminate(System.String)">
            <summary>
            Creates a Terminate Instruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nop">
            <summary>
            Create a Nop Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nop(System.String)">
            <summary>
            Create a Nop instruction with comment
            </summary>
            <param name="comment">A Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Move(System.Int32,System.Int32)">
            <summary>
            Create a Move instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Move(System.Int32,System.Int32,System.String)">
            <summary>
            Create a Move isntruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Load(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a Load Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Load(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a Load Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Store(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a Store Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Store(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a Store Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Push(System.Int32,System.String)">
            <summary>
            Create a Push Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Push(System.Int32)">
            <summary>
            Create a Push Instruction
            </summary>
            <param name="r1">Register 1</param>
            <returns></returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Pop(System.Int32,System.String)">
            <summary>
            Create a Pop Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Pop(System.Int32)">
            <summary>
            Create a Pop Instruction
            </summary>
            <param name="r1">Register 1</param>
            <returns></returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.In(System.Int32,System.Int32,System.String)">
            <summary>
            Create a In Instruction with comment
            </summary>
            <param name="r1">Register 1</param>
            <param name="port">The port to read from</param>
            <param name="comment">Comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.In(System.Int32,System.Int32)">
            <summary>
            Create a Pop Instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="port">The port to read from</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Out(System.Int32,System.Int32)">
            <summary>
            Creates an Out Instruction
            </summary>
            <param name="r1">Register to send to port</param>
            <param name="port">Port to write to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Out(System.Int32,System.Int32,System.String)">
            <summary>
            Creates an Out Instruction with comment
            </summary>
            <param name="r1">Register to send to port</param>
            <param name="port">The port to write to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Jump(System.Int32,System.Int32)">
            <summary>
            Creates an Jump Instruction
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to jump to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Jump(System.Int32,System.Int32,System.String)">
            <summary>
            Creates an Jump Instruction with comment
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to jump to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Call(System.Int32,System.Int32)">
            <summary>
            Creates a Call Instruction
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to call to</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Call(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a Call Instruction with comment
            </summary>
            <param name="r1">Index modifier to address or address</param>
            <param name="address">Address to call to</param>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Terminate">
            <summary>
            Creates a Terminate Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Terminate(System.String)">
            <summary>
            Creates a Terminate Instruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Return">
            <summary>
            Creates a Terminate Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Return(System.String)">
            <summary>
            Creates a Terminate Instruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Add Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Add(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AddInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Sub(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Sub Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Sub(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a SubInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Mul(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Mul Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Mul(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a MulInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Div(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Div Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Div(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a DivInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.And(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a And Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.And(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AndInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Or(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Or Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Or(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a AndInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Not(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Not Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Not(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NotInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Xor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Xor Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Xor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a XortInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nand(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Nand Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nand(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NandtInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Nor Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Nor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Creates a NortInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Inc(System.Int32)">
            <summary>
            Creates a Inc Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Inc(System.Int32,System.String)">
            <summary>
            Creates a IncInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Dec(System.Int32)">
            <summary>
            Creates a Dec Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Dec(System.Int32,System.String)">
            <summary>
            Creates a DecInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Compare(System.Int32,System.Int32)">
            <summary>
            Creates a Compare Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.Compare(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a CompareInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.ClearCompare">
            <summary>
            Creates a ClearCompare Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.ClearCompare(System.String)">
            <summary>
            Creates a ClearCompareInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JE(System.Int32,System.Int32)">
            <summary>
            Creates a JE Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JE(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JNE(System.Int32,System.Int32)">
            <summary>
            Creates a JNE Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JNE(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JGT(System.Int32,System.Int32)">
            <summary>
            Creates a JGT Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JGT(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JLT(System.Int32,System.Int32)">
            <summary>
            Creates a JLT Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JLT(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JZ(System.Int32,System.Int32)">
            <summary>
            Creates a JZ Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JZ(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JNZ(System.Int32,System.Int32)">
            <summary>
            Creates a JNZ Instruction
            </summary>
            <returns>Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionFactory.JNZ(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a JNEInstruction with comment
            </summary>
            <param name="comment">The comment</param>
            <returns>Instruction</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionParseException">
            <summary>
            This exception is thrown whenever the assembly routines run into an error in the 
            format of the instructions
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionParseException.#ctor(System.String)">
            <summary>
            Constructs an InstructionParseException from a string
            </summary>
            <param name="message">The error message</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.InstructionParseException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs an InstructionParseException from a format string and array of arguments
            </summary>
            <param name="format">The format string</param>
            <param name="args">The arguments</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.LoadStoreBase.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionCodes,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Base class for Load and Store instructions handles all parsing in a consistent manner
            </summary>
            <param name="code">The specific code for this instruction</param>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">An imediate value</param>
            <param name="address">An address</param>
            <param name="comment">A comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.LoadStoreBase.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine">The line of assembly to create the instruction from</param>
            <param name="factory">the instruction factory for this kernel</param>
            <returns>An Instruction object</returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.LoadStoreBase.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.LoadInstruction">
            <summary>
            Loads data from memory to a register
            Load r1, value          ; imediate
            Load r1, $address       ; direct addressing
            Load r1, r2            ; indirect addressing
            Load r1, r2, address   ; indexed indirect addressing  
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.LoadInstruction.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a load instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode">
            <summary>
            Addressing modes supported by instructions that use addresses.
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode.Direct">
            <summary>
            Direct addressing is where an address appears in memory imediately following the instruction code
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode.Indirect">
            <summary>
            Indirect addressing is where a register contains the address to use
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode.Indexed">
            <summary>
            Indexed addressing is where an address appears imediately following the instruction code and a register 
            indexes to some point beyond that address.
            </summary>
            
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode.IndexedInderect">
            <summary>
            This is where two registers are used to compute the final address, one contains the address the other indexes into
            memory.
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.AddressingMode.Imediate">
            <summary>
            Imediate takes an operand imediately following the op code
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction">
            <summary>
            Moves data from register 1 to register 2
            Move r1, r2
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a MoveInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a MoveInstruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction)">
            <summary>
            Copies a MoveInstruction to this new object
            </summary>
            <param name="inst">The instruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            When implemented assembles a string into this op code
            </summary>
            <param name="assemblyLine"></param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns></returns>
            <exception>Throws an ApplicationExceptiion if the string is not valid for this instruction</exception>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MoveInstruction.DisAssemble">
            <summary>
            When implemented produces a string representation of the instructiuon as assembly language
            </summary>
            <returns>The assembly language code as a string</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.MulInstruction">
            <summary>
            Muls data from register 1 to register 2
            Mul r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NandInstruction">
            <summary>
            Nands data from register 1 to register 2
            Nand r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction">
            <summary>
            Represents No Operation instruction
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction.#ctor">
            <summary>
            Construciton a Nop Instruciton
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction.#ctor(System.String)">
            <summary>
            Constructs a NOP instruction
            </summary>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction)">
            <summary>
            Copy constructor
            </summary>
            <param name="inst">The NopInstruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Assembly a Nop Instruction
            </summary>
            <param name="assemblyLine">Assembly line representing a NOP</param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns>The instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction.DisAssemble">
            <summary>
            Generates Assembly code for a Nop instruction
            </summary>
            <returns></returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NorInstruction">
            <summary>
            Nors data from register 1 to register 2
            Nor r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NotInstruction">
            <summary>
            Nots data from register 1 to register 2
            Not r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.OrInstruction">
            <summary>
            Ors data from register 1 to register 2
            Or r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PopInstruction">
            <summary>
            Represents a single atomic Push instruction.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PopInstruction.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a Pop instruction
            </summary>
            <param name="r1">register</param>
            <param name="comment">comments</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PopInstruction.#ctor(System.Int32)">
            <summary>
            Constructs a Pop instruction
            </summary>
            <param name="r1">register</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PopInstruction.DisAssemble">
            <summary>
            Converts instruction to assembly language representation
            </summary>
            <returns>String assembly language representation</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PushInstruction">
            <summary>
            Represents a single atomic Push instruction.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PushInstruction.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a Push instruction
            </summary>
            <param name="r1">register</param>
            <param name="comment">comments</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PushInstruction.#ctor(System.Int32)">
            <summary>
            Constructs a Push instruction
            </summary>
            <param name="r1">register</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.PushInstruction.DisAssemble">
            <summary>
            Converts instruction to assembly language representation
            </summary>
            <returns>String assembly language representation</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction">
            <summary>
            Represents No Operation instruction
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction.#ctor">
            <summary>
            Construciton a Nop Instruciton
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction.#ctor(System.String)">
            <summary>
            Constructs a NOP instruction
            </summary>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction.#ctor(LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.NopInstruction)">
            <summary>
            Copy constructor
            </summary>
            <param name="inst">The NopInstruction to copy</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Assembly a Nop Instruction
            </summary>
            <param name="assemblyLine">Assembly line representing a NOP</param>
            <param name="factory">The instruction factory for this kernel</param>
            <returns>The instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.ReturnInstruction.DisAssemble">
            <summary>
            Generates Assembly code for a Nop instruction
            </summary>
            <returns></returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.StoreInstruction">
            <summary>
            Stores data from a register to a memory
            Store value, $address   ; imediate
            Store r1, $address      ; direct addressing
            Store r1, r2            ; indirect addressing
            Store r1, r2, address   ; indexed indirect addressing  
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.StoreInstruction.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Create a store instruction
            </summary>
            <param name="r1">Register 1</param>
            <param name="r2">Register 2</param>
            <param name="value">Imediate value</param>
            <param name="address">Address</param>
            <param name="comment">Comment</param>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.SubInstruction">
            <summary>
            Subs data from register 1 to register 2
            Sub r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.Symbols">
            <summary>
            Special symbols used to control instruction code operations
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.Symbols.NullAddress">
            <summary>
            Designates an address that is not valid.  This is for absolute addresses only, a relative address of -1 is computed against
            an absolute address to obtain another absolute address.
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.Symbols.NullRegister">
            <summary>
            Designates that no register is specified.  In some instances this may result in the CPUKernel or OSKernal selecting an unused register.
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction">
            <summary>
            Class representing a Teminatate Instruction
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction.#ctor">
            <summary>
            Construciton a Terminate Instruciton
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction.#ctor(System.String)">
            <summary>
            Constructs a Terminate instruction
            </summary>
            <param name="comment">Comment</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction.Assemble(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Assembles a Terminate Instruction
            </summary>
            <param name="factory">The instruction factory</param>
            <param name="assemblyLine">The line of assembly code</param>
            <returns>Terminate Instruction</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction.DisAssemble">
            <summary>
            Disassemble an instruction to assembly code
            </summary>
            <returns>The assembly code</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.TerminateInstruction.NewInstruction(LagDaemon.ExperimentalOS.CPU.Interfaces.IInstructionFactory,System.String)">
            <summary>
            Create a new instruction from the factory
            </summary>
            <param name="factory">The factory to use</param>
            <param name="comment">Any comments for the instruction</param>
            <returns>Terminate Instruction</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.InstructionSet.XorInstruction">
            <summary>
            Xors data from register 1 to register 2
            Xor r1, r2
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolCache">
            <summary>
            The SymbolCache is used to store symbols found and the location where an address
            needs to be place, but prior to the symbol being defined.  Once the symbol is defined the
            SymbolCache is checked to find all location where the address needs to be placed.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolCache.#ctor(System.String)">
            <summary>
            Construct a SymbolCache for the specified scope
            </summary>
            <param name="scope">The scope of this SymbolCacne</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolCache.Add(System.String,System.Int32)">
            <summary>
            Adds a Symbol and address to the Cache creating the list of addresses 
            if this this the first time the symbol is added. 
            </summary>
            <param name="symbol">The symbol to add and address for</param>
            <param name="address">The address where the symbol resides</param>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolCache.Item(System.String)">
            <summary>
            Produces and Emumeration of all addresses in this scope that are 
            associated with the supplied symbol
            </summary>
            <param name="symbol">The symbol for this scope</param>
            <returns>An enumeration of all addresses for this symbol</returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolCache.Scope">
            <summary>
            The Scope of this SymbolCache
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolTable">
            <summary>
            A SymbolTable is a look up table and cross reference for Symbols that have been assigned an address.
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolTable.#ctor(System.String)">
            <summary>
            Constructs a SymbolTable for the specified scope
            </summary>
            <param name="scope">The Scope of this SymbolTable</param>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolTable.Item(System.Int32)">
            <summary>
            Produces the Symbol for the specified address (reverse lookup)
            </summary>
            <param name="address">The address</param>
            <returns>The Symbol</returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolTable.Item(System.String)">
            <summary>
            Produces an address for a given symbol
            </summary>
            <param name="symbol">The Symbol</param>
            <returns>The address</returns>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.CPU.CPUKernel.SymbolTable.Scope">
            <summary>
            The Scope of this SymbolTable
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.BinarySerializer">
            <summary>
            A class for Binary Serialization
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.Serializer">
            <summary>
            Abstract class representing a Serializert
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.Interfaces.ISerializer">
            <summary>
            Represents a Serializer
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Interfaces.ISerializer.Serialize``1(``0)">
            <summary>
            Serialize to the stream based on serialization mode
            </summary>
            <typeparam name="T">The type of object ot serialize</typeparam>
            <param name="obj">The object to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Interfaces.ISerializer.Deserialize``1">
            <summary>
            Deserialize from the stream
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <returns>The desierialized object</returns>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.OS.Serializer.stream">
            <summary>
            The serialization stream
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Serializer.#ctor(System.IO.Stream)">
            <summary>
            Constructs a serializer for this stream
            </summary>
            <param name="stream">The stream to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Serializer.Serialize``1(``0)">
            <summary>
            Serialize to the stream based on serialization mode
            </summary>
            <typeparam name="T">The type of object ot serialize</typeparam>
            <param name="obj">The object to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Serializer.Deserialize``1">
            <summary>
            Deserialize from the stream
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <returns>The desierialized object</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.BinarySerializer.#ctor(System.IO.Stream)">
            <summary>
            Constructs a Binary Serializer
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.BinarySerializer.Serialize``1(``0)">
            <summary>
            Serialize an object of type T
            </summary>
            <typeparam name="T">The type of object to serialize</typeparam>
            <param name="obj">The object to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.BinarySerializer.Deserialize``1">
            <summary>
            Deserialize an object of type T from the stream
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <returns>The deserialized object</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.Interfaces.IProgramLoader">
            <summary>
            Represents a program loader
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Interfaces.IProgramLoader.LoadProgram(System.IO.FileStream)">
            <summary>
            Load a program from a stream using the serialization mode
            </summary>
            <param name="stream">The stream to load from</param>
            <returns>A program from the stream</returns>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Interfaces.IProgramLoader.SaveProgram(LagDaemon.ExperimentalOS.OS.Program,System.IO.FileStream)">
            <summary>
            Saves a program to the stream using the specified serialization mode
            </summary>
            <param name="program">The program to save</param>
            <param name="stream">The stream to save to</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Interfaces.IProgramLoader.Mode(LagDaemon.ExperimentalOS.OS.SerializationModes)">
            <summary>
            The serialization mode to use
            </summary>
            <param name="mode">The serialization mode</param>
            <returns>IProgramLoader interface</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.Program">
            <summary>
            Represents an executable program with meta data describing the program
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.Program.#ctor(System.String)">
            <summary>
            Constructs a program
            </summary>
            <param name="name">The name of the program</param>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Name">
            <summary>
            Gets or Sets the program Name
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Mode">
            <summary>
            Gets or Sets the program Mode
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Code">
            <summary>
            Gets or sets the Code for this program
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Symbols">
            <summary>
            Gets or sets the Symbols for this program
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.SymbolCache">
            <summary>
            Gets or sets the Symbol Cache for this program
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Author">
            <summary>
            Gets or sets the Author of this program
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Copyright">
            <summary>
            Gets or sets the Copyright for this program
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.Program.Version">
            <summary>
            Gets or sets the Version of this program
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.ProgramLoaderFactory">
            <summary>
            Produces a program loader singleton
            </summary>
        </member>
        <member name="P:LagDaemon.ExperimentalOS.OS.ProgramLoaderFactory.Loader">
            <summary>
            Gets the ProgramLoader singleton
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.SerializationModes">
            <summary>
            Represents the serialization modes of the serializers
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.OS.SerializationModes.Binary">
            <summary>
            Serializer to binary file
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.OS.SerializationModes.XML">
            <summary>
            Serialize to XML
            </summary>
        </member>
        <member name="F:LagDaemon.ExperimentalOS.OS.SerializationModes.Soap">
            <summary>
            Serialize to SOAP
            </summary>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.SoapSerializer">
            <summary>
            Class representing a Soap Serializer
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.SoapSerializer.#ctor(System.IO.Stream)">
            <summary>
            Constructs a SoapSerializer
            </summary>
            <param name="stream">The stream to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.SoapSerializer.Serialize``1(``0)">
            <summary>
            Serialize an object to the stream
            </summary>
            <typeparam name="T">The type of object to serialize</typeparam>
            <param name="obj">The object to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.SoapSerializer.Deserialize``1">
            <summary>
            Deserialize an object from the stream
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <returns>The deserialized object</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.OS.XMLSerializer">
            <summary>
            Represents an XMLSerializer
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.XMLSerializer.#ctor(System.IO.Stream)">
            <summary>
            Constructs an XMLSerializer
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.XMLSerializer.Serialize``1(``0)">
            <summary>
            Serialize an object of type T
            </summary>
            <typeparam name="T">The Type of object to serialize</typeparam>
            <param name="obj">The object to serialize</param>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.OS.XMLSerializer.Deserialize``1">
            <summary>
            Deserialize an object of type T
            </summary>
            <typeparam name="T">The type of object to deserialize</typeparam>
            <returns>The deserialized object</returns>
        </member>
        <member name="T:LagDaemon.ExperimentalOS.Utilities.MacroExpander">
            <summary>
            Expands Macros used in Assembly Files
            <remarks>This routine is experimental and may not be implemented in release</remarks>
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.Utilities.MacroExpander.#ctor">
            <summary>
            Parses and expands a macro that had a definition of the for define MyMacro(args) = now is the {0} for all good {1} to come to the aid of their {2}
            such that MyMacro(time, men, country) expands to "now is the time for all good men to come to the aid of their country
            </summary>
        </member>
        <member name="M:LagDaemon.ExperimentalOS.Utilities.MacroExpander.AddMacro(System.String)">
            <summary>
            Add a Macro to the expander
            </summary>
            <param name="macro">The Macro to add</param>
        </member>
    </members>
</doc>
